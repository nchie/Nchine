const char *vertexGeometryShader =
        "#version 330 core\n"
                "layout (location = 0) in vec3 aPos;\n"
                "layout (location = 1) in vec2 aTexCoords;\n"
                "layout (location = 2) in vec3 aNormal;\n"
                "\n"
                "out vec3 FragPos;\n"
                "out vec3 Normal;\n"
                "out vec2 TexCoords;\n"
                "\n"
                "layout (std140) uniform shader_data\n"
                "{ \n"
                "    mat4 view_projection;\n"
                "    mat4 prev_view_projection;\n"
                "    mat4 projection;\n"
                "    mat4 view;\n"
                "    mat4 inverse_view;"
                "};"
                "uniform mat4 model;\n"
                "\n"
                "void main()\n"
                "{\n"
                "    vec4 worldPos = model * vec4(aPos, 1.0);\n"
                "    FragPos = worldPos.xyz; \n"
                "    TexCoords = aTexCoords;\n"
                "    \n"
                "    mat3 normalMatrix = transpose(inverse(mat3(model)));\n"
                "    Normal = normalMatrix * aNormal;\n"
                "   \n"
                "   gl_Position = projection * view * worldPos;"
                "}";

const char *fragmentGeometryShader =
        "#version 330 core\n"
                "layout (location = 0) out vec4 gDiffuseSpec;\n"
                "layout (location = 1) out vec4 gNormal;\n"
                "\n"
                "in vec3 Normal;  \n"
                "in vec3 FragPos;  \n"
                "in vec2 TexCoords;  \n"
                "\n"
                "layout (std140) uniform shader_data\n"
                "{ \n"
                "    mat4 view_projection;\n"
                "    mat4 prev_view_projection;\n"
                "    mat4 projection;\n"
                "    mat4 view;\n"
                "    mat4 inverse_view;"
                "};"

                "uniform sampler2D texture_diffuse1;\n"
                "uniform sampler2D texture_specular1;\n"
                "\n"
                "void main()\n"
                "{\n"
                "    // Store the per-fragment normals into the gbuffer\n"
                "    gDiffuseSpec.rgb = texture(texture_diffuse1, TexCoords).rgb;\n"
                "    // store specular intensity in gDiffuse's alpha component\n"
                "    gDiffuseSpec.a = texture(texture_specular1, TexCoords).r;\n"
                "    gNormal = vec4(normalize(Normal), 0.0);\n"
                "} ";


const char *vertexDeferredShader =
        "#version 330 core\n"
        "\n"
        "layout (location = 0) in vec3 aPos;\n"
        "layout (location = 1) in vec2 aTexCoords;\n"
        "\n"
        "out vec3 EyeDirection;\n"
        "out vec2 TexCoords;\n"
        "\n"
        "layout (std140) uniform shader_data\n"
        "{ \n"
        "    mat4 view_projection;\n"
        "    mat4 prev_view_projection;\n"
        "    mat4 projection;\n"
        "    mat4 view;\n"
        "    mat4 inverse_view;\n"
        "    mat4 inverse_projection;\n"
        "    vec2 half_size_near_plane;\n"
        "};\n"
        "\n"
        "void main()\n"
        "{\n"
        "   TexCoords = aTexCoords;\n"
        "   EyeDirection = vec3((2.0 * half_size_near_plane * aTexCoords) - half_size_near_plane , -1.0);\n"
        "   gl_Position = vec4(aPos.xy, 0, 1);\n"
        "}";

const char *fragmentDeferredShader =
        "#version 330 core\n"
        "//Fragment shader\n"
        "layout (location = 0) out vec3 FragColor;\n"
        "in vec3 EyeDirection;\n"
        "in vec2 TexCoords;\n"
        "\n"
        "layout (std140) uniform shader_data\n"
        "{ \n"
        "    mat4 view_projection;\n"
        "    mat4 prev_view_projection;\n"
        "    mat4 projection;\n"
        "    mat4 view;\n"
        "    mat4 inverse_view;\n"
        "    mat4 inverse_projection;\n"
        "    vec2 half_size_near_plane;\n"
        "};\n"
        "\n"
        "uniform sampler2D gDiffuseSpecular;\n"
        "uniform sampler2D gNormal;\n"
        "uniform sampler2D gDepth;\n"
        "\n"
        "vec4 CalcEyeFromWindow(in float windowZ, in vec3 eyeDirection, in mat4 projMatrix)\n"
        "{\n"
        "  float ndcZ = 2.0 * windowZ - 1;\n"
        "  float eyeZ = -projMatrix[3][2] / ((projMatrix[2][3] * ndcZ) - projMatrix[2][2]);\n"
        "  return vec4(EyeDirection * eyeZ, 1);\n"
        "}\n"
        "\n"
        "void main()\n"
        "{\n"
        "  vec4 viewSpacePosition = CalcEyeFromWindow(texture(gDepth, TexCoords).x, EyeDirection, projection);\n"
        "  FragColor = (inverse_view*viewSpacePosition).rgb;\n"
        "}";





const char *fragmentDeferredShader2 =
        "#version 330 core\n"
                "layout (location = 0) out vec3 FragColor;\n"
                "\n"
                "in vec2 TexCoords;  \n"
                "in vec3 EyeDirection;\n"
                "\n"
                "layout (std140) uniform shader_data\n"
                "{ \n"
                "    mat4 view_projection;\n"
                "    mat4 prev_view_projection;\n"
                "    mat4 projection;\n"
                "    mat4 view;\n"
                "    mat4 inverse_view;\n"
                "    mat4 inverse_projection;\n"
                "    vec2 half_size_near_plane;\n"
                "};\n"
                "uniform sampler2D albedo;\n"
                "uniform sampler2D normal;\n"
                "uniform sampler2D depth;\n"
                "\n"
                "float near = 0.1; \n"
                "float far  = 100.0; \n"
                "\n"
                "float LinearizeDepth(float depth) \n"
                "{\n"
                "    float z = depth * 2.0 - 1.0; // back to NDC \n"
                "    return (2.0 * near * far) / (far + near - z * (far - near));\t\n"
                "}\n"
                "\n"
                "void main()\n"
                "{\n"
                "    float depth = texture(depth, TexCoords).x;"
                "    float z = depth * 2.0 - 1.0;\n"
                "    vec4 clipSpacePosition = vec4(TexCoords.x * 2.0 - 1.0, TexCoords.y * 2.0 - 1.0, z, 1.0);\n"
                "    vec4 viewSpacePosition = inverse_projection * clipSpacePosition;\n"
                "    viewSpacePosition /= viewSpacePosition.w;\n"
                "    vec4 worldSpacePosition = inverse_view * viewSpacePosition;\n"
                "    FragColor = worldSpacePosition.xyz; \n"
                "} ";